/**
 * @file TestLib.h
 * @brief Documentation of a fake API
 * 
 * This file is for testing documentation generated by Doxygen.
 * It has no real applicable functionality.
 * @author 2bndy5
 * @date December 9, 2021
 * @version 0.1
 * @copyright
 * @include{doc} LICENSE
 */

#include <cstdint>

/**
 * A namespace just for our inheritance example.
 */
namespace InheritanceNamespace {

/** @brief An Abstract class for polymorphism. */
class AbstractClass {

public:

    /** An empty contrustor. */
    AbstractClass() : parentVar(false) {};

    /**
     * @name Implementation-less function
     * 
     * An example of an inner group (group within a structure).
     * @{
     */
    /** @brief  A pure virtual function. */
    virtual void morphMe() = 0;
    /**@} */

protected:

    /**
     * @name Protected Members
     * 
     * Another example of an inner group that gets its own table.
     * @{
     */

    /** @brief  A variable declared in the abstract parent class. */
    bool parentVar;

    /**
     * @brief An `inline` protected function
     * @param[in] nonop A boolean that does nothing. Defaults to `false`.
     * @return The same value as the @p nonop parameter.
     * @retval true If @p nonop was passed as `true`.
     * @retval false If @p nonop was passed as `false`.
     */
    inline bool has_code(bool nonop = false) { return nonop; }
    /**@}*/
};

/** @brief A derivative of AbstractClass */
struct TestClass : public AbstractClass {

    /**
     * @brief A usable function.
     * @param var Some number parameter.
     * @param nonop Some boolean parameter.
     */
    void morphMe(uint16_t var, bool nonop) {
        myVar = var; // should probably initialize this in c'tor properly
        if (has_code(nonop)) {
            parentVar = true;
        }
        else {
            myVar++;
        }
    }

private:
    
    /** @brief A private variable specific to the child class. */
    uint8_t myVar;

};

} // end InheritanceNamespace

/**
 * @brief A namespace just for our template example.
 */
namespace templateNamespace {

/**
 * @brief A templated class.
 * @tparam T Some data of your choosing 
 * @tparam R Some other data of your choosing.
 */
template<typename T, typename R>
class TemplateClass {

public:
    /**
     * @brief A constructor that takes in templated data.
     * @param var_1 Some data to be used.
     * @param var_2 Some data to be used.
     */
    TemplateClass(T var_1, R var_2) : var1(var_1), var2(var_2) {}

    /** 
     * @brief An overloaded function
     * @param check An example parameter.
     */
    void test(T check);

    /** 
     * @brief An overloaded function
     * @param check An example parameter.
     */
    void test(R check);

private:
    /** @brief  Some encapsulated data. */
    T var1;
    /** @brief Some encapsulated data. */
    R var2;
};

/**
 * @brief A helpful specialization instantiated for getting the app developed quickly.
 * 
 * In this example, this object specializes using
 * - `int(1)`
 * - `bool(0)`
 */
extern TemplateClass quickStarter = TemplateClass<int, bool>(1, 0);

} // end templateNamespace


/**
 * @defgroup enum_options Enumerated Options
 * @brief A modularized document for an enum in the global scope.
 * 
 * Multiple enums might best be namespaced for transparent scoping.
 * @{
 */

/**
 * @brief A generic enumeration of specific options/flags
 * 
 * Enums are great for users as they don't need to remember any values that
 * might be specific to a project's internal machinery.
 */
enum OptionsEnum
{
    /**
     * @brief Optional configurator 1
     * 
     * This enumerator's value is `0`.
     */
    CONFIG_OPT_1 = 0,
    /** 
     * @brief Optional configurator 2
     * 
     * This enumerator's value is `1`.
     */
    CONFIG_OPT_2,
    /**
     * @brief Optional configurator 3
     * 
     * This enumerator's value is `2`.
     */
    CONFIG_OPT_3,
};

/** @} */
